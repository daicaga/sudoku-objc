head	1.7;
access;
symbols;
locks
	mwade:1.7; strict;
comment	@// @;


1.7
date	2007.03.06.22.35.04;	author mwade;	state Exp;
branches;
next	1.6;

1.6
date	2007.03.06.22.30.29;	author mwade;	state Exp;
branches;
next	1.5;

1.5
date	2007.03.06.20.13.38;	author mwade;	state Exp;
branches;
next	1.4;

1.4
date	2007.03.06.03.15.02;	author mwade;	state Exp;
branches;
next	1.3;

1.3
date	2007.03.06.00.15.01;	author mwade;	state Exp;
branches;
next	1.2;

1.2
date	2007.03.03.22.21.33;	author mwade;	state Exp;
branches;
next	1.1;

1.1
date	2007.02.26.18.05.05;	author mwade;	state Exp;
branches;
next	;


desc
@Initial checkin.
@


1.7
log
@This is the best thus far.
@
text
@/* Individual.m
 * Individual class implementation file.
 *
 * Michael J Wade 
 * mike@@iammyownorg.org 
 * Copyright (c) 2007
 * 
 */

#import "Individual.h"

#define CHECKPT {printf("Checkpoint: %s, line %d\n", __FILE__,__LINE__);\
		fflush(stdout);}
#define STREAMS 256
#define OPEN   1
#define CLOSED 0

@@implementation Individual

- copy {
	Individual *newIndividual;
	int i,j,c;
		
	//Create a new individual
	newIndividual = [Individual new];

	//Copy all instance values into the new individual
	newIndividual->ni 	= ni;
	newIndividual->nj 	= nj;
	newIndividual->sub_ni	= sub_ni;
	newIndividual->sub_nj 	= sub_nj;
	newIndividual->chromLen = chromLen;
	newIndividual->maxAllele= maxAllele; 
	newIndividual->maxFit	= maxFit;
	newIndividual->fitness 	= fitness;
	newIndividual->nOpen 	= nOpen;
	newIndividual->nClosed 	= nClosed;
	
	//Allocate the new chromosone
	newIndividual->chromosone = NULL;
	newIndividual->chromosone = (Gene*)objc_calloc(chromLen,sizeof(Gene));
	
	//Allocate the totals array.  This is used to keep track of
	//what has been used and how many times
	newIndividual->totals = (int*)calloc(maxAllele,sizeof(int));
	for( i=0; i < maxAllele; i++ )
		newIndividual->totals[i] = totals[i];
	
	//Copy in the new chromosone
	for( i=0; i < chromLen; i++ ){
		newIndividual->chromosone[i].status = chromosone[i].status;		
		newIndividual->chromosone[i].allele = chromosone[i].allele;		
		newIndividual->chromosone[i].xLoc   = chromosone[i].xLoc;
		newIndividual->chromosone[i].yLoc   = chromosone[i].yLoc;
		newIndividual->chromosone[i].Loc   = chromosone[i].Loc;
		//Allocate the new possibles array per gene
		newIndividual->chromosone[i].possibles = NULL;
		newIndividual->chromosone[i].possibles = (int*)objc_calloc(maxAllele,sizeof(int));
		for( j=0; j < maxAllele; j++ )
			newIndividual->chromosone[i].possibles[j] = chromosone[i].possibles[j];
	}

//	printf("Created new individual:\n");
	return newIndividual;
}

- free {
	int i;

	for( i=0; i < chromLen; i++ )
		free(chromosone[i].possibles);

	free(chromosone);
	//printf("freed the chromosone!");
	[super free];
	return nil;
}

- initialize:(IOD)anIOD m:(int)m n:(int)n subm:(int)sm subn:(int)sn maxFit:(int)mf{

	int i,j,c;

	//Setup the chromosone parameters
	ni = m;
	nj = n;
	sub_ni = sm;
	sub_nj = sn;
	chromLen = ni*nj;
	maxAllele = n; //maximum allele value can't exceed n
	maxFit = mf; //maximum fitness of a chromosone
	fitness = 0.0;
	nOpen = 0;
	nClosed = 0;
	
	//Allocate the new chromosone
	chromosone = NULL;
	chromosone = (Gene*)objc_calloc(chromLen,sizeof(Gene));
	
	//Allocate the totals array.  This is used to keep track of
	//what has been used and how many times
	totals = (int*)calloc(maxAllele,sizeof(int));

	//Read in the new chromosone
	//for( i=0; i<ni; i++ )
	for( j=(nj-1); j>=0; j-- )
	{
	//	for( j=0; j<nj; j++ )
		for( i=0; i<ni; i++ )
		{
			c = fgetc( anIOD );
			if ( c == '.' ){
				chromosone[nj*i + j].allele = 0;
				chromosone[nj*i + j].status = OPEN;
				nOpen++;
	
				chromosone[nj*i + j].xLoc = i;
				chromosone[nj*i + j].yLoc = j;
				chromosone[nj*i + j].Loc = (nj*i+j);

				//Allocate the new possibles array per gene
				chromosone[nj*i + j].possibles = NULL;
				chromosone[nj*i + j].possibles = (int*)objc_calloc(maxAllele,sizeof(int));
			}
			else
			{
				c = c - '0';
				if ( (c < 1) || (c > maxAllele) ) 
				{
					i--;
				}else{
					chromosone[nj*i + j].allele = c;
					chromosone[nj*i + j].status = CLOSED;
					nClosed++;
					
					chromosone[nj*i + j].xLoc = i;
					chromosone[nj*i + j].yLoc = j;
					chromosone[nj*i + j].Loc = nj*i+j;

					//Allocate the new possibles array per gene
					chromosone[nj*i + j].possibles = NULL;
					chromosone[nj*i + j].possibles = (int*)objc_calloc(maxAllele,sizeof(int));

					//Increment the total used values array
					totals[c-1]++;
				}
			}

		}
		fgetc(anIOD);
	}
	return self;
}

- load:(IOD)anIOD m:(int)m n:(int)n subm:(int)sm subn:(int)sn maxFit:(int)mf{
	
	//Free the memory previously belonging to contents
	free(chromosone); 

	//Re-initialize the puzzle
	return [self initialize:(anIOD) m:(m) n:(n) subm:sm subn:sn maxFit:mf];
}

- gene:(int)loc allele:(int)val {
	//printf("gene: %d val:%d\n",loc,val);
	
	//Decrement total count from old value
	if(chromosone[loc].allele){
		totals[(chromosone[loc].allele - 1)]--;
	}
	
	//Set the new value
	chromosone[loc].allele = val;
	
	//If, the new value is not 0, increase the total count
	if(chromosone[loc].allele){
		totals[(chromosone[loc].allele - 1)]++;
	}

	return self;
} 

//The randomize message tells an individual to randomize the 
//open values on it's chromosone
- randomize {
	int i;
	
	for(i = 0; i < chromLen; i++){
		SelectStream(time(NULL));
		if(chromosone[i].status == OPEN){
			[self gene:i allele: Equilikely(1,maxAllele)];
			//printf("%d\n",chromosone[i].allele);
		}
	}
			
	return self;
}

//The value being enumerated by this method symbolizes how 
//incorrect the vector is.
- (signed int) evalVector:(int*)v
{
	int i, vFit, *a;
	a = (int*)malloc(maxAllele*sizeof(int));
	vFit = 0;

	//Initialize a unit vector
	for( i=0; i<ni; i++ )
		a[i] = 1;

	//For each V_i decrement A_(V_i) by 1
	//as long as V_i != 0
	for( i=0; i<ni; i++ )
		if ( v[i] )
			a[v[i]-1]--;

	//A perfect score is 0
	//Anything else is going to be a negative return value
	for(i = 0; i < ni; i++){
		if(a[i] > 0)
			a[i] = 0; //This was a blank spot
		vFit += a[i];	
	}

	free(a);

	return vFit;
}

//This function is Sudoku specific.  It should be over-ridden by any subclass.
- (int) evalFitness {
	int i,j,m,n,w,*v;

	//Allocate a vector that will be used to evaluate the 
	//genes of the chromosone.
	v = (int*)malloc(maxAllele*sizeof(int));
	
	//Reset the fitness value to maximum.
	//Everyone starts with an A+ ...
	fitness = maxFit;
	//printf("fit = %d\n",fitness);

	for( i=0; i<ni; i++ ) // check rows
	{
		for( j=0; j<nj; j++ )
			v[j] = chromosone[nj*i + j].allele;
		
		//Decrease fitness accourdingly	
		fitness += [self evalVector:v];
		//printf("%d += %d\n",fitness,[self evalVector:v]);
	}
	
	for( j=0; j<nj; j++ ) // check columns
	{
		for( i=0; i<ni; i++ )
			v[i] = chromosone[nj*i + j].allele;
	
		//Decrease fitness accourdingly	
		fitness += [self evalVector:v];
	}
	
	for( n=0; n<sub_nj; n++ ) // check boxes
		for( m=0; m<sub_ni; m++ )
		{
			w = 0;
			for( j=0; j<sub_ni; j++ )
				for( i=0; i<sub_nj; i++ ){
					v[w] = 
					chromosone[(nj*( (m*sub_ni)+i) ) + 
						       ( (n*sub_nj)+j )].allele;
					w++;
				}
			//Decrease fitness accourdingly	
			fitness += [self evalVector:v];
		}

	free(v);
	return fitness;
}


/*
 * certaintyOf(gene) - Returns the certainty that a gene's allele is absolute.
 *
 */
#if 0
- (double) certaintyOf:(Gene*)gene
{
	int i,j;
	int iOffset, jOffset;
	double c;

	//(Re)Set possibles Array
	for(i=0; i < ni; i++)
		gene->possibles[i] = i+1;

	//eliminate possible row values
	j = gene->yLoc;
	for(i=0; i<ni; i++)
		//if( chromosone[nj*i + j].status == CLOSED )
			if(chromosone[nj*i+j].allele)
				gene->possibles[(chromosone[nj*i+j].allele - 1)] = 0;

	//eliminate possible col values
	i = gene->xLoc;
	for(j=0; j<nj; j++)
		//if( chromosone[nj*i + j].status == CLOSED )
			if(chromosone[nj*i+j].allele)
				gene->possibles[(chromosone[nj*i+j].allele - 1)] = 0;

	//eliminate possible box values (this is tricky)
	/*BOXES:
	*	A | B | C
	*	D | E | F
	*	G | H | I
	*/
	iOffset = gene->xLoc - (gene->xLoc % sub_ni);
	jOffset = gene->yLoc - (gene->yLoc % sub_nj);
	
	for( j=jOffset; j<(jOffset+sub_nj); j++ )
		for( i=iOffset; i<(iOffset+sub_ni); i++ )
			//if( chromosone[nj*i + j].status == CLOSED )
				if(chromosone[nj*i+j].allele)
					gene->possibles[(chromosone[nj*i+j].allele - 1)] = 0;

	//Compute the score based on the remaining possible values.
	c=0.0;
	for(i=0; i < maxAllele; i++)
	{
		if(gene->possibles[i])
			c+=1.;
	}

	return (((double)maxAllele)-c)/(double)maxAllele;
	
}
#endif

#if 1
- (double) certaintyOf:(Gene *)gene {

	int i,j,iOffset,jOffset,*a;
	double rules,overlap,c;

	//Precaution:  Regardless of what is around, any gene with a closed status
	//		has a certainty of 100% since it is a known truth.
	if(gene->status == CLOSED)
		return 1.0;//100%
	
	//Measure the certainty of this gene
	//	certainty = [summation of (Values per Vector) ] - Overlap
//	rules = 3;
//	overlap = 1;//Each rule/constraint will overlap the same gene
//	c = (((double)maxAllele)*rules)-overlap;	

	//Initialize a unit vector with zeros
	a = (int*)objc_calloc(maxAllele,sizeof(int));
	
	//(Re)Set possibles Array (used in A*)
	for(i=0; i < ni; i++)
		gene->possibles[i] = i+1;
	
	//eliminate possible row values
	j = gene->yLoc;
	for(i=0; i<maxAllele; i++){
		if( /*chromosone[nj*i + j].status == CLOSED &&*/ chromosone[nj*i + j].allele > 0){
			a[(chromosone[nj*i + j].allele)-1]++;
			//c--;
			gene->possibles[(chromosone[nj*i+j].allele - 1)] = 0;
		}
	}
		

	//eliminate possible col values
	i = gene->xLoc;
	for(j=0; j<maxAllele; j++){
		if( /*chromosone[nj*i + j].status == CLOSED &&*/ chromosone[nj*i + j].allele > 0){
			a[(chromosone[nj*i + j].allele)-1]++;
			//c--;
			gene->possibles[(chromosone[nj*i+j].allele - 1)] = 0;
		}
	}

	//eliminate box connections (this is tricky)
	/*BOXES:
	*	A | B | C
	*	D | E | F
	*	G | H | I
	*/
	
	//Compute the offset into each subregion.
	//Previous code used a bunch of if/else logic to accomplish
	//the same task!
	iOffset = gene->xLoc - (gene->xLoc % sub_ni);
	jOffset = gene->yLoc - (gene->yLoc % sub_nj);
	
	for( j=jOffset; j<(jOffset+sub_nj); j++ )
		for( i=iOffset; i<(iOffset+sub_ni); i++ ){
			if(/* chromosone[nj*i + j].status == CLOSED &&*/ chromosone[nj*i + j].allele > 0){
				a[(chromosone[nj*i + j].allele)-1]++;
				gene->possibles[(chromosone[nj*i+j].allele - 1)] = 0;
			}
		}

	//Compute the certainty value based on the remaining potential
	//values in a[].  This is a reduced form of the equation outlined
	//in the paper.
	c=0;
	for(i=0;i<maxAllele;i++){
		if(a[i] > 0)
			c++;
	}
	
	objc_free(a);
	
	//return (c/((((double)maxAllele)*rules)-overlap));
	return  ((double)(maxAllele - c))/((double)maxAllele);
}
#endif

/*
 * removeCertainty(gene) - Returns the certainty that a gene's allele is absolute.
 *
 */
- removeUncertainty:(Gene *)gene below:(double)t {

	int i,j,iOffset,jOffset,*a;
	double rules,overlap,c;

	//Precaution:  Regardless of what is around, any gene with a closed status
	//		has a certainty of 100% since it is a known truth.
	if(gene->status == CLOSED)
		return self;//100%
	
	//Measure the certainty of this gene
	//	certainty = [summation of (Values per Vector) ] - Overlap
//	rules = 3;
//	overlap = 1;//Each rule/constraint will overlap the same gene
//	c = (((double)maxAllele)*rules)-overlap;	
	a = (int*)malloc(maxAllele*sizeof(int));

	//Initialize a unit vector
	for( i=0; i<ni; i++ )
		a[i] = 0;
	
	//eliminate possible row values
	j = gene->yLoc;
	for(i=0; i<maxAllele; i++)
		if( chromosone[nj*i + j].status == CLOSED )
			a[(chromosone[nj*i + j].allele)-1]++;
			//c--;

	//eliminate possible col values
	i = gene->xLoc;
	for(j=0; j<maxAllele; j++)
		if( chromosone[nj*i + j].status == CLOSED )
			a[(chromosone[nj*i + j].allele)-1]++;
			//c--;

	//eliminate box connections (this is tricky)
	/*BOXES:
	*	A | B | C
	*	D | E | F
	*	G | H | I
	*/
	
	//Compute the offset into each subregion.
	//Previous code used a bunch of if/else logic to accomplish
	//the same task!
	iOffset = gene->xLoc - (gene->xLoc % sub_ni);
	jOffset = gene->yLoc - (gene->yLoc % sub_nj);
	
	for( j=jOffset; j<(jOffset+sub_nj); j++ )
		for( i=iOffset; i<(iOffset+sub_ni); i++ )
			if( chromosone[nj*i + j].status == CLOSED )
				a[(chromosone[nj*i + j].allele)-1]++;

	//Compute the certainty value based on the remaining potential
	//values in a[].  This is a reduced form of the equation outlined
	//in the paper.
	c=0;
	for(i=0;i<maxAllele;i++){
		if(a[i] > 0)
			c++;
	}

	if(c <= t){
		for(i=0;i<maxAllele;i++){
			if(a[i] > 0)
				[self gene:(nj*(gene->xLoc) + gene->yLoc) allele:a[i] ];
		}
	}
	
	
	free(a);
	
	return self;
}

//This will return the Measurement of Uniqueness
//	In this measurement, the MU is the highest degree of uncertainty
- (double) MU {
	int i;
	double mu;
	
	mu = 0.0;
	//Remove Givens
	for(i=0; i<chromLen; i++)
		//if(mu < [self certaintyOf:(&chromosone[i])])
			mu += [self certaintyOf:(&chromosone[i])];

	return mu/(double)chromLen; //Normalized MU
}


/*
 * vague - will return 1 is the solution is improper and 0 if proper
 */
- (int) vague {

	//While there exists an x in P such that C(x) < C_k
	int i;
	double C_k, C_v;
	C_k = 2.0;  C_v = 8.0;
	int c = 1;
	
	while(c){
		//Cycle over chromosone and remove uncertainty
		for(i=0;i<chromLen;i++)
			[self removeUncertainty:&chromosone[i] below:C_k];

		//Cycle over chromosone and check for C(x) < C_k
		for(i=0;i<chromLen;i++){
			if([self certaintyOf:&chromosone[i] ] <= C_k)
				c = 1;
			else
				c = 0;
		}
	
	}
	
	//Cycle over chromosone and check for C(x) < C_k
	for(i=0;i<chromLen;i++){
		if([self certaintyOf:&chromosone[i] ] >= C_k)
			return 1;
	}

	//return 0 if non-vague/proper
	return 0;
}

- (BOOL) compareFitness: anIndividual {
    return (BOOL) (fitness < [anIndividual fitness]); 
}

- (BOOL) moveRemainsAt:(int)loc {
	int i;

	//Be certain that this is a valid location
	if(loc > chromLen || loc < 0)
		return 0;

	//Return TRUE if a possible exists
	for(i=0; i<maxAllele; i++)
		if(chromosone[loc].possibles[i])
			return 1;

	return 0;
}

- countTotals {
	int i;
	for(i=0;i<maxAllele;i++)
		totals[i] = 0;
	for(i=0;i<chromLen;i++)
		if(chromosone[i].allele)
			totals[ chromosone[i].allele - 1]++;

	return self;
}

-printTotals {
	int i;
	
	for(i=0;i<maxAllele;i++)
		printf(" %d ", totals[i]);
	
	return self;
}

//Assume that possibles has been computed...
- (int) mostLikelyAt:(int)loc {
	int i,val;
	double p,tp;
	//printf("mostLikelyAt:%d\n",loc);
	

	//[self countTotals];	
	val = -1;//chromosone[loc].possibles[0];
	tp = 110.0;
	p = 10.0;
#if 0
	for(i=0;i<maxAllele;i++)
		printf(" %d ", chromosone[loc].possibles[i]);
	printf(" | ");
	for(i=0;i<maxAllele;i++)
		printf(" %d ", totals[i]);
#endif
	
	//Search for the possible value with ?? highest or lowest probability?
	for(i=0; i<maxAllele; i++){
		if(chromosone[loc].possibles[i])
			tp = (((double)totals[i]) / ((double)maxAllele));
		if( tp < p){
			p = tp;
			val = chromosone[loc].possibles[i];
		}
	}

	//Eliminate this possible from future choices
	if(val > 0)
		chromosone[loc].possibles[val-1] = 0;

#if 0
	printf("\n");
	for(i=0;i<maxAllele;i++)
		printf(" %d ", chromosone[loc].possibles[i]);
	printf(" | ");
	for(i=0;i<maxAllele;i++)
		printf(" %d ", totals[i]);
#endif
	return val;
}

//The maxAllele is determined by the matrix size.
//TODO: rethink this and change it to be more dynamic.
//	perhaps make it a command line arg.
- (int) maxAllele {
	return maxAllele; 
}

- (int) chromLen {
	return chromLen;
}

- (int) alleleAt:(int)loc{
	return chromosone[loc].allele;
}

- (int) statusAt:(int)loc{
	return chromosone[loc].status;
}

//Display the puzzle's contents
- printOn:(IOD)anIOD {
	int i, j;
	double c;
	Gene *gene;
	
	//TODO: determine if the DOS shell has color codes
	//terminal color codes (UNIX):
	const char *const green = "\033[0;0;32m";
	const char *const red = "\033[0;0;31m";
	const char *const blue = "\033[0;0;34m";
	const char *const normal = "\033[0m";

	//Print Allele Values
	printf("Gene Alelles:\n");
	for( j=(nj-1); j>=0; j-- )
	{
		//fprintf(anIOD,"%i: ", i+1);
		for( i=0; i<ni; i++ )
		{
			gene = &chromosone[nj*i + j];
			if(chromosone[nj*i + j].allele == 0){
				fprintf(anIOD,green); //show blanks
				fprintf(anIOD,"%u", gene->allele); //show open
				//fprintf(anIOD,"(%d,%d) %u", gene->xLoc, gene->yLoc, gene->allele); //show open
			}else if(chromosone[nj*i + j].status == OPEN){
				fprintf(anIOD,red); //show open
				fprintf(anIOD,"%u",  chromosone[nj*i + j].allele); //show open
			}else{
				fprintf(anIOD,normal); //show closed
				fprintf(anIOD,"%u",  chromosone[nj*i + j].allele); //show open
			}

			
				fprintf(anIOD," ");
		}
		fprintf(anIOD,normal); //return to normal
		fprintf(anIOD,"\n");
	}
	//Print variables:
	fprintf(anIOD, "Size: %d X %d\tFitness: %d\tMU:%f\n",ni,nj,fitness,[self MU]);
	
	return self;
}

- printChromosoneOn:(IOD)anIOD {
	int i, j, n;
	double c;
	Gene *gene;
	
	//Print Allele Values
	printf("Gene Alelles:\n");
	for( j=(nj-1); j>=0; j-- )
	{
		//fprintf(anIOD,"%i: ", i+1);
		for( i=0; i<ni; i++ )
		{
			//Print the border
			if((i%sub_ni)==0 )
				fprintf(anIOD,"|| ");
			
			//Print the gene
			if(chromosone[nj*i+j].allele < 10)
				fprintf(anIOD," ");
			fprintf(anIOD,"%u",  chromosone[nj*i + j].allele); //show open
		
			fprintf(anIOD," ");
		}
		
		//Print the border
		if((j%sub_nj)==0 ){
			fprintf(anIOD,"\n");
			for(n=0;n<(ni*3)+sub_nj*3;n++)
				fprintf(anIOD,"m");
			fprintf(anIOD,"\n");
		}
		
		fprintf(anIOD,"\n");
	}
	
	return self;
}
	
//Display the puzzle's contents
- printCertainty:(IOD)anIOD {
	int i, j;
	double c;
	
	//TODO: determine if the DOS shell has color codes
	//terminal color codes (UNIX):
	const char *const green = "\033[0;0;32m";
	const char *const red = "\033[0;0;31m";
	const char *const blue = "\033[0;0;34m";
	const char *const normal = "\033[0m";
	//Print the Certainty of each gene
	printf("\nCertainty of Allele Prediction:\n");
	//for( i=0; i<ni; i++ )
	for( j=(nj-1); j>=0; j-- )
	{
		//fprintf(anIOD,"%i: ", i+1);
	//	for( j=0; j<nj; j++ )
		for( i=0; i<ni; i++ )
		{
			c = [self certaintyOf:(&chromosone[nj*i + j]) ];
			
			if(c == 1.){ //100%
				fprintf(anIOD,green); 
				fprintf(anIOD,"%1.3f", c);
			}else if(c == 0.9){//90%, this is a given.
				fprintf(anIOD,blue); 
				fprintf(anIOD,"%1.3f", c);
			}else{
				fprintf(anIOD,red); //Not for certain..
				fprintf(anIOD,"%1.3f", c);
			}
				fprintf(anIOD," ");
		}
		fprintf(anIOD,normal); //return to normal
		fprintf(anIOD,"\n");
	}

	//Print variables:
	fprintf(anIOD, "Size: %d X %d\tFitness: %d\tMU:%f\n",ni,nj,fitness,[self MU]);
	
	return self;
}

- (double) phenotype {
	return phenotype;
}
- (int) fitness {
	return fitness;
}

- fitness:(int)newFitVal {
	fitness = newFitVal;
	return self;
}

- (int) open {
	int i;
	nOpen = 0;
	for(i=0;i<chromLen;i++)
		if(chromosone[i].status == OPEN)
			nOpen++;
	
	return nOpen;
}

- (int) closed {
	int i;
	nClosed = 0;
	for(i=0;i<chromLen;i++)
		if(chromosone[i].status == CLOSED)
			nClosed++;

	return nClosed;
}

@@end
@


1.6
log
@This appears to be working using probabilities or forward search.
@
text
@d594 1
a594 1
	printf("mostLikelyAt:%d\n",loc);
d601 1
a601 1
#if 1
d623 1
a623 1
#if 1
@


1.5
log
@This bites but it works.
@
text
@d164 1
a164 1
	printf("gene: %d val:%d\n",loc,val);
d285 54
a353 1
	a = (int*)malloc(maxAllele*sizeof(int));
d355 2
a356 3
	//Initialize a unit vector
	for( i=0; i<ni; i++ )
		a[i] = 0;
d365 1
a365 1
		if( chromosone[nj*i + j].status == CLOSED )
d368 2
a369 2
		
		gene->possibles[(chromosone[nj*i+j].allele - 1)] = 0;
d376 1
a376 1
		if( chromosone[nj*i + j].status == CLOSED )
d379 2
a380 2
		
		gene->possibles[(chromosone[nj*i+j].allele - 1)] = 0;
d398 1
a398 1
			if( chromosone[nj*i + j].status == CLOSED )
d400 2
a401 2
		
			gene->possibles[(chromosone[nj*i+j].allele - 1)] = 0;
d413 1
a413 1
	//free(a);
d418 1
d599 2
a600 2
	tp = 0.0;
	p = -10.0;
d608 2
d613 1
a613 1
		if( tp > p){
d619 2
a620 2
	//printf("returning %d\n",val);
	if(val)
@


1.4
log
@Updating to include totals[]
@
text
@d41 1
a41 1
	newIndividual->chromosone = (Gene*)malloc(chromLen*sizeof(Gene));
d55 6
d68 5
d97 1
a97 1
	chromosone = (Gene*)objc_malloc(chromLen*sizeof(Gene));
d118 1
d122 1
a122 1
				chromosone[nj*i + j].possibles = (int*)objc_malloc(maxAllele*sizeof(int));
d137 1
d141 1
a141 1
					chromosone[nj*i + j].possibles = (int*)objc_malloc(maxAllele*sizeof(int));
d164 3
a166 2
	//printf("chromosone[%d].allele = %d\n",loc,val);
	//Decrement count of old allele
a168 1
		totals[val-1]++;
d170 1
d173 5
d190 1
a190 1
			chromosone[i].allele = Equilikely(1,maxAllele);
d361 1
a361 1
	free(a);
d436 1
a436 1
				gene->allele = a[i];
a444 11
//This will return the Measurement of Uniqueness
//	In this measurement, the MU is a summation of certainty
#if 0
- (double) MU {
	int i;
	double mu;
	
	mu = 0.0;
	//Remove Givens
	for(i=0; i<chromLen; i++)
		mu += [self certaintyOf:(&chromosone[i])];
a445 3
	return mu/(double)chromLen; //Normalized MU
}
#endif
d502 77
@


1.3
log
@I'm going to add more to this later and optimize the removeCertainty feature.
This revision also includes the saving of possibles in the certaintyOf: message.
@
text
@d43 6
d88 3
d129 3
d152 6
d159 1
@


1.2
log
@*** empty log message ***
@
text
@d268 4
d274 1
a274 1
	for(i=0; i<maxAllele; i++)
d278 4
d285 1
a285 1
	for(j=0; j<maxAllele; j++)
d289 3
d307 1
a307 1
		for( i=iOffset; i<(iOffset+sub_ni); i++ )
d310 3
d326 1
a326 1
	return maxAllele - c;///maxAllele;
@


1.1
log
@Initial revision
@
text
@d417 2
a418 2
		if(mu < [self certaintyOf:(&chromosone[i])])
			mu = [self certaintyOf:(&chromosone[i])];
d420 1
a420 1
	return mu;///(double)chromLen; //Normalized MU
@
