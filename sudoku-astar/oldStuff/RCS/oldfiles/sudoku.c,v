head	1.1;
access;
symbols;
locks; strict;
comment	@ * @;


1.1
date	2007.02.27.21.15.30;	author mwade;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/*
 * sudoku.c - single file implementation of Sudoku puzzle creator/solver
 *            for use in CPSC 580.
 *
 */

#include <stdio.h>
#include <stdlib.h>

/*
 * Problem Definitions
 *
 */

#define GRID_SIZE 	9
#define BOX_SIZE  	3
#define OPEN 		0
#define CLOSED 		1

typedef struct BOX
{
	int blanks;
} BOX;

typedef struct SLOT
{
	int val;
	int status;
	int possibles[9];
	int i,j;
	int score;
	struct SLOT *next;
	//BOX *region;
} SLOT;

struct SLOT *start = NULL;
struct SLOT *head = NULL; //used to keep the open list for A*
//static BOX regions[9];	
static SLOT grid[GRID_SIZE][GRID_SIZE] = { 0 };

/*
 * Code to manage options
 *
 */

static int bSolve = 0;
static int bCreate = 0;
static int bHTML   = 0;
static int  iDiff   = 1;

void usage()
{
	printf( "usage: sudoku {-s -c -h -d:(1...5)} <prob >solution\n" );
	printf( "        -s(olve)\n" );
	printf( "        -c(reate)\n" );
	printf( "        -h(tml)\n" );
	printf( "        -d(ifficulty):<1...5> (1 = easiest)\n" );
	printf( "\n" );
	printf( "Note: -c,-s will create, then solve, a puzzle\n" );
	printf( "\n" );
}

int parseArgs( int c, char *v[] )
{
	int i;

	if ( c == 1 )
	{
		usage();
		return 0;
	}

	for( i=1; i<c; i++ )
	{
		switch( v[i][1] )
		{
			case 's':
				bSolve = 1;
				break;

			case 'c':
				bCreate = 1;
				break;

			case 'h':
				bHTML = 1;
				break;

			case 'd':
				iDiff = v[i][3] - '0';	
				if ( (iDiff < 1) || (iDiff > 5) )
				{
					printf( "%d not valid for -d:\n", iDiff );
					usage();
					return 0;
				}
				break;

			default:
				printf( "-%c is illegal option\n", v[i][1] );
				usage();
				return 0;
		}
	}

	return 1;
}


/*
 * Routines to read in, write out, and access grid
 *
 * Format is 9 lines, with 10 chars each 9 (.|[1-9]) and eol
 *
 */

int readGrid( FILE *fp )
{
	int i, j, c;

	for( i=0; i<GRID_SIZE; i++ )
	{
		for( j=0; j<GRID_SIZE; j++ )
		{
			c = fgetc( fp );
			if ( c == '.' )
				grid[i][j].val = 0;
			else
			{
				c = c - '0';
				if ( (c < 1) || (c > 9) )
					return 0;
				grid[i][j].val = c;
				grid[i][j].status = CLOSED;
			}
		}
		fgetc(fp);
	}
	return 1;
}

int writeGrid( FILE *fp )
{
	int i, j;

	for( i=0; i<GRID_SIZE; i++ )
	{
		for( j=0; j< GRID_SIZE; j++ )
			fputc( grid[i][j].val ? (grid[i][j].val+'0') : '.', fp );
		fputc( '\n', fp );
	}
	return 1;
}

//terminal color codes:
const char *const green = "\033[0;40;32m";
const char *const red = "\033[0;40;31m";
const char *const blue = "\033[0;40;34m";
const char *const normal = "\033[0m";

void showGrid()
{

printf("%sopen%s | %sclosed%s | %scurrent%s\n",green,normal,red,normal,blue,normal);
	int i, j;

	for( i=0; i<GRID_SIZE; i++ )
	{
		printf("%i: ", i+1);
		for( j=0; j<GRID_SIZE; j++ )
		{
			if ( grid[i][j].status == OPEN )
			{	
				if( head == &grid[i][j] )
					printf("%s%u %s", blue, grid[i][j].val, normal); //current
				else
					printf("%s%u %s", green, grid[i][j].val, normal); //show open
			}
			else
				printf("%s%u %s",red, grid[i][j].val, normal); //show closed
		}
		printf("\n");
	}
}



/*
 * Routines to display grid in HTML
 *
 */

int writeSubTable( FILE *fp, int r, int c, char *bg )
{
	int i, n, j, m;

	n = r+3;
	m = c+3;

	fprintf( fp, "<TABLE border=2 BGCOLOR=\"%s\">\n", bg );
	fprintf( fp, "<TBODY>\n" );
	for( i=r; i<n; i++ )
	{
		fprintf( fp, "<TR>\n" );
		for( j=c; j<m; j++ )
		{
			fprintf( fp, "<TD>\n" );
			fprintf( fp, "%c", grid[i][j].val ? (grid[i][j].val+'0') : '.' );
			fprintf( fp, "</TD>\n" );
		}
		fprintf( fp, "</TR>\n" );
	}
	fprintf( fp, "</TBODY>\n" );
	fprintf( fp, "</TABLE>\n" );

	return 1;
}

int writeHTMLPuzzle( FILE *fp )
{
	int i, j;

	fprintf( fp, "<HTML>\n" );
	fprintf( fp, "<BODY BGCOLOR=\"white\">\n" );

	fprintf( fp, "<TABLE border=3>\n" );
	fprintf( fp, "<TBODY>\n" );
	for( i=0; i<3; i++ )
	{
		fprintf( fp, "<TR>\n" );
		for( j=0; j<3; j++ )
		{
			fprintf( fp, "<TD>\n" );
			writeSubTable( fp, i*3, j*3, ( (i+j)%2 ? "white" : "grey" ) );
			fprintf( fp, "</TD>\n" );
		}
		fprintf( fp, "</TR>\n" );
	}
	fprintf( fp, "</TBODY>\n" );
	fprintf( fp, "</TABLE>\n" );

	fprintf( fp, "   </BODY>\n" );
	fprintf( fp, "</HTML>\n" );
	return( 1 );
}

/*
 * Rountine to validate puzzle
 *
 * AJN - Changed isSolved and isValid to return 1 if solution, 
 *       -1 if legal but not solved and 0 if illegal.
 *
 */

int isValid( int v[] )
{
	int i, s, a[GRID_SIZE];

	for( i=0; i<GRID_SIZE; i++ )
		a[i] = 0;

	for( i=0; i<GRID_SIZE; i++ )
		if ( v[i] )
			a[v[i]-1]++;
	
	for( i=0, s=0; i<GRID_SIZE; i++ )
		if ( a[i] > 1 )
			return 0;
		else if ( a[i] )
			s += a[i];

	return( s == 9 ? 1 : -1 );
}

static long int checkCount = 0;

int isSolved()
{
	int i, j, k, l, v[GRID_SIZE];
	int c1, c2, c3;

	checkCount++;
	if ( !(checkCount % 1000000) )
		printf( "%ld, ", checkCount );

	for( i=0; i<GRID_SIZE; i++ ) // check rows
	{
		for( j=0; j<GRID_SIZE; j++ )
			v[j] = grid[i][j].val;
		if ( !(c1 = isValid( v )) )
			return( 0 );
	}

	for( j=0; j<GRID_SIZE; j++ ) // check columns
	{
		for( i=0; i<GRID_SIZE; i++ )
			v[i] = grid[i][j].val;
		if ( !(c2 = isValid( v )) )
			return( 0 );
	}

	for( i=0; i<BOX_SIZE; i++ ) // check boxes
		for( j=0; j<BOX_SIZE; j++ )
		{
			for( k=0; k<BOX_SIZE; k++ )
				for( l=0; l<BOX_SIZE; l++ )
					v[k*BOX_SIZE+l] = grid[i*BOX_SIZE+k][j*BOX_SIZE+l].val;
			if ( !(c3 = isValid( v )) )
				return( 0 );
		}

	return( (c1+c2+c3) == BOX_SIZE ? 1 : -1 );
}

/*
 * Routines to solve puzzle
 *
 */
 
/*
 *     A* FUNCTIONS
 */

int createList = 0;
int countOpen = 0; 

void openSlot(struct SLOT *newSLOT)
{
	countOpen++;
	
	if (start == NULL) //first time through
	{
		start = newSLOT;
		head = newSLOT;
		newSLOT->next = NULL;
	}

	//set the new slot @@ the end of the list.	
	head->next = newSLOT;
	//Move the head.
	head = newSLOT;
	newSLOT->next = NULL;
}

void closeSlot(struct SLOT *closedSLOT)
{
	countOpen--;
	closedSLOT->status = CLOSED;
	head = start;

	//closedSLOT is either last in the list, or last slot left
	if( closedSLOT->next == NULL )
	{
		if( start->next == NULL) //make an empty list
			start = head = NULL;
		else
		{
			while( head->next != closedSLOT )
			{
				head = head->next;
			}
			head->next = NULL;
		}
		
	}

	//closedSLOT if the first in the list?
	else if (start == closedSLOT )
		start = head = closedSLOT->next;

	//closedSLOT is in the middle somewhere.
	else
	{
		while( head->next != closedSLOT )
		{
			head = head->next;
		}
		head->next = closedSLOT->next;
		closedSLOT->next = NULL;
	}
}

void createOpenList() 
{
	int i,j;
	for( i=0; i<GRID_SIZE; i++ )
		for( j=0; j<GRID_SIZE; j++ )
		{
			if (grid[i][j].val == 0)
			{
				grid[i][j].i = i;
				grid[i][j].j = j;
				grid[i][j].status = OPEN;
				openSlot(&grid[i][j]);
			}
			else
				grid[i][j].status = CLOSED;
		}	
	//set the head to the start of the list
	head = start;
}

void scoreOpenSlots() 
{
//printf("scores:\n");
	int i;	

	head = start;
	if (countOpen == 1)
		head->score = costFromStart(head) + heuristic(head);
	else	
		for(i=0; i < countOpen; i++)//Traverse the list
		{	
			head->score = costFromStart(head) + heuristic(head);
			head = head->next;
		}
	//set the head to the start of the list
	head = start;
}

int costFromStart( struct SLOT *slot)
{
	return 0;
}

int heuristic( struct SLOT *slot)
{
	int i,j,k,l,h;
	int v[GRID_SIZE];

	//reset possibles
	for(i=0; i < GRID_SIZE; i++)
		slot->possibles[i] = i+1;

	//eliminate possible row values
	i = slot->i;
	for(j=0; j<GRID_SIZE; j++)
		slot->possibles[(grid[i][j].val - 1)] = 0;

	//eliminate possible col values
	j = slot->j;
	for(i=0; i<GRID_SIZE; i++)
		slot->possibles[(grid[i][j].val - 1)] = 0;

	//eliminate possible box values (this is tricky)
	/*BOXES:
	*	A | B | C
	*	D | E | F
	*	G | H | I
	*/
	if( slot->i <= 2 )
	{
		if( slot->j <= 2 )
		{
			//BOX: A
			for( k=0; k<BOX_SIZE; k++ )
				for( l=0; l<BOX_SIZE; l++ )
					slot->possibles[(grid[k][l].val - 1)] = 0;
		}
		else if( slot->j <= 5 )
		{
			//BOX: B
			for( k=0; k<BOX_SIZE; k++ )
				for( l=BOX_SIZE; l<(BOX_SIZE*2); l++ )
					slot->possibles[(grid[k][l].val - 1)] = 0;
		}
		else //slot->j > 7
		{
			//BOX: C
			for( k=0; k<BOX_SIZE; k++ )
				for( l=BOX_SIZE*2; l<(BOX_SIZE*3); l++ )
					slot->possibles[(grid[k][l].val - 1)] = 0;
		}
	}
	else if( slot->i <= 5 )
	{
		if( slot->j <= 2 )
		{
			//BOX: D
			for( k=BOX_SIZE; k<(BOX_SIZE*2); k++ )
				for( l=0; l<BOX_SIZE; l++ )
					slot->possibles[(grid[k][l].val - 1)] = 0;
		}
		else if( slot->j <= 5 )
		{
			//BOX: E
			for( k=BOX_SIZE; k<(BOX_SIZE*2); k++ )
				for( l=BOX_SIZE; l<(BOX_SIZE*2); l++ )
					slot->possibles[(grid[k][l].val - 1)] = 0;
		}
		else //slot->j > 7
		{
			//BOX: F
			for( k=BOX_SIZE; k<(BOX_SIZE*2); k++ )
				for( l=BOX_SIZE*2; l<(BOX_SIZE*3); l++ )
					slot->possibles[(grid[k][l].val - 1)] = 0;
		}
	}
	else //slot->i > 7
	{
		if( slot->j <= 2 )
		{
			//BOX: G
			for( k=(BOX_SIZE*2); k<(BOX_SIZE*3); k++ )
				for( l=0; l<BOX_SIZE; l++ )
					slot->possibles[(grid[k][l].val - 1)] = 0;
		}
		else if( slot->j <= 5 )
		{
			//BOX: H
			for( k=(BOX_SIZE*2); k<(BOX_SIZE*3); k++ )
				for( l=BOX_SIZE; l<(BOX_SIZE*2); l++ )
					slot->possibles[(grid[k][l].val - 1)] = 0;
		}
		else //slot->j > 7
		{
			//BOX: H
			for( k=(BOX_SIZE*2); k<(BOX_SIZE*3); k++ )
				for( l=BOX_SIZE*2; l<(BOX_SIZE*3); l++ )
					slot->possibles[(grid[k][l].val - 1)] = 0;
		}
	}
	
	//count the remaining possibles and return as heuristic.
	h=0;
	for(i=0; i < GRID_SIZE; i++)
	{
		if(slot->possibles[i] != 0)
			h++;
	}
	return h;
}

SLOT *optimalSlot()
{
	SLOT *lowestSLOT = NULL;
	int lowestScore = 999;
	head = start;
	//check for last node
	if( countOpen == 1)
		return start;
	else
	{
		while( head->next != NULL )
		{
			if ( head->score < lowestScore && head->status != CLOSED )
			{
				lowestScore = head->score;
				lowestSLOT = head;
			}
			head = head->next;
		}
	}
	return lowestSLOT;
}

int findSolution_Astar()
{
	int i;
	struct SLOT *slot = NULL;

	if (!createList){
		createOpenList();
		createList = 1;
	}
	printf("# Open: %u\n", countOpen);
	showGrid();
	
	int solved = 0;
	while(solved != 1)
	{
		//TODO: modify this to change invalid entries to zeros and create a new list.
		if( solved = -1 && countOpen == 0)
			return 0;
		//Score the open slots
		scoreOpenSlots();
		//Find the slot with lowest score (optimal).
		slot = optimalSlot();
		if ( slot == NULL)
			return 1;
		for(i=0; i<GRID_SIZE; i++)
		{
			if ( slot->possibles[i] != 0)
			{
				slot->val = slot->possibles[i];
				slot->status = CLOSED;
			}
		}
		//Move slot to closed list
		if( slot->val != 0)
			closeSlot(slot);
		
		//Redisplay the grid
		showGrid();	
		solved = isSolved();
	}	
	//showGrid();
	return 1;
}

/*
 *     Depth First Search
 */
int findSolution_DFS()
{
	int i, j, k;
	int check;

	check = isSolved();
	if ( check == 1 )
		return 1;
	else if ( check == 0 )
		return 0;

	for( i=0; i<GRID_SIZE; i++ )
		for( j=0; j<GRID_SIZE; j++ )
		{
			if ( !grid[i][j].val )
			{
				for( k=1; k<=GRID_SIZE; k++ )
				{
					grid[i][j].val = k;
					if ( findSolution_DFS() )
						return 1;
				}
				grid[i][j].val = 0;
				return 0;
			}
		}

	return( 0 );
}

int solvePuzzle()
{
	//return( findSolution_DFS() );
	return( findSolution_Astar() );
}

/*
 * Routines to create puzzle
 *
 */

int randInt( int f, int l )
{
	return (f + (double)rand () * (l - f + 1) / RAND_MAX);
}

void createNewPuzzle( int diff )
{
	int r, c, i, n;
	static int seed[] = { 0, 3, 6, 1, 4, 7, 2, 5, 8 };

	for( c=0; c<9; c++ )
		for( r=0; r<9; r++ )
			grid[r][c].val = ( ( seed[c] + r ) % 9) + 1;
		
	n = 1<<(2+diff);
	for( i=0; i<n; i++ )
		grid[randInt(0,8)][randInt(0,8)].val = 0;
}


/*
 * main routine
 *
 */

int main( int argc, char *argv[] )
{
	if ( !parseArgs( argc, argv ) )
		exit( 1 );

	if (  !bCreate )
	{
		if ( !readGrid( stdin ) )
		{
			fprintf( stderr, "error: bad problem input\n" );
			exit( 1 );
		}
	}
	else
		createNewPuzzle( iDiff );

	if ( bSolve )
	{
		if ( !solvePuzzle() )
		{
			fprintf( stderr, "error: puzzle is unsolveable\n" );
			exit( 1 );
		}
		printf( "Check Count: %ld\n", checkCount );
	}

	if ( bHTML )
		writeHTMLPuzzle( stdout );
	else
		writeGrid( stdout );

	return( 0 );
}

@
