head	1.1;
access;
symbols;
locks; strict;
comment	@ * @;


1.1
date	2007.02.27.21.15.30;	author mwade;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/*
 * sudoku.c - single file implementation of Sudoku puzzle creator/solver
 *            for use in CPSC 580.
 *
 */

#include <stdio.h>
#include <time.h>

/*
 * Problem Definitions
 *
 */

#define GRID_SIZE 9
#define BOX_SIZE  3
#define OPEN 	  0
#define CLOSED 	  1

//Represents the individual nodes on the grid
typedef struct SLOT
{
	int val;
	int possible_values[GRID_SIZE];
	int *box_score;
	int h; // heuristic = # possible values + box score
	int score; // score = 9*9 - heuristic + box_score
	int state; // OPEN || CLOSED
} SLOT;

static SLOT grid[GRID_SIZE][GRID_SIZE] = { 0 };
static int closed_nodes = 0;

/*
 * Code to manage options
 *
 */

static int bSolve = 0;
static int bCreate = 0;
static int bHTML   = 0;
static int  iDiff   = 1;

void usage()
{
	printf( "usage: sudoku {-s -c -h -d:(1...5)} <prob >solution\n" );
	printf( "        -s(olve)\n" );
	printf( "        -c(reate)\n" );
	printf( "        -h(tml)\n" );
	printf( "        -d(ifficulty):<1...5> (1 = easiest)\n" );
	printf( "\n" );
	printf( "Note: -c,-s will create, then solve, a puzzle\n" );
	printf( "\n" );
}

int parseArgs( int c, char *v[] )
{
printf("parseArgs:\n");
	int i;

	if ( c == 1 )
	{
		usage();
		return 0;
	}

	for( i=1; i<c; i++ )
	{
		switch( v[i][1] )
		{
			case 's':
				bSolve = 1;
				break;

			case 'c':
				bCreate = 1;
				break;

			case 'h':
				bHTML = 1;
				break;

			case 'd':
				iDiff = v[i][3] - '0';
				if ( (iDiff < 1) || (iDiff > 5) )
				{
					printf( "%d not valid for -d:\n", iDiff );
					usage();
					return 0;
				}
				break;

			default:
				printf( "-%c is illegal option\n", v[i][1] );
				usage();
				return 0;
		}
	}

	return 1;
}


/*
 * Routines to read in, write out, and access grid
 *
 * Format is 9 lines, with 10 chars each 9 (.|[1-9]) and eol
 *
 */

int readGrid( FILE *fp )
{
printf("readGrid:\n");
	int i, j, c;

	for( i=0; i<GRID_SIZE; i++ )
	{
		for( j=0; j<GRID_SIZE; j++ )
		{
			c = fgetc( fp );
			if ( c == '.' ){
				grid[i][j].val = 0;
				grid[i][j].state = OPEN;
			}
			else
			{
				c = c - '0';
				if ( (c < 1) || (c > 9) )
					return 0;
				grid[i][j].val = c;
				grid[i][j].state = CLOSED;
				closed_nodes++;
			}
		}
		fgetc(fp);
	}
	showGrid();
	return 1;
}

int writeGrid( FILE *fp )
{
printf("writeGrid:\n");
	int i, j;

	for( i=0; i<GRID_SIZE; i++ )
	{
		for( j=0; j< GRID_SIZE; j++ )
			fputc( grid[i][j].val ? (grid[i][j].val+'0') : '.', fp );
		fputc( '\n', fp );
	}
}

//terminal color codes:
const char *const green = "\033[0;40;32m";
const char *const red = "\033[0;40;31m";
const char *const blue = "\033[0;40;34m";
const char *const normal = "\033[0m";

int showGrid()
{
printf("currert grid status: %u closed\n",closed_nodes);
printf("%sopen%s | %sclosed%s | %scurrent%s\n",green,normal,red,normal,blue,normal);
	int i, j;

	for( i=0; i<GRID_SIZE; i++ )
	{
		printf("%i: ", i+1);
		for( j=0; j<GRID_SIZE; j++ )
		{
			if ( grid[i][j].state == OPEN )
				printf("%s%u %s", green, grid[i][j].val, normal); //show this as open
			else
				printf("%s%u %s",red, grid[i][j].val, normal); //show as closed		
		}
		printf("\n");
	}
	return 1;
}



/*
 * Routines to display grid in HTML
 *
 */

int writeSubTable( FILE *fp, int r, int c, char *bg )
{
printf("writeSubTable:\n");
	int i, n, j, m;

	n = r+3;
	m = c+3;

	fprintf( fp, "<TABLE border=2 BGCOLOR=\"%s\">\n", bg );
	fprintf( fp, "<TBODY>\n" );
	for( i=r; i<n; i++ )
	{
		fprintf( fp, "<TR>\n" );
		for( j=c; j<m; j++ )
		{
			fprintf( fp, "<TD>\n" );
			fprintf( fp, "%c", grid[i][j].val ? (grid[i][j].val+'0') : '.' );
			fprintf( fp, "</TD>\n" );
		}
		fprintf( fp, "</TR>\n" );
	}
	fprintf( fp, "</TBODY>\n" );
	fprintf( fp, "</TABLE>\n" );

	return 1;
}

int writeHTMLPuzzle( FILE *fp )
{
printf("writeHTMLPuzzle:\n");
	int i, j;

	fprintf( fp, "<HTML>\n" );
	fprintf( fp, "<BODY BGCOLOR=\"white\">\n" );

	fprintf( fp, "<TABLE border=3>\n" );
	fprintf( fp, "<TBODY>\n" );
	for( i=0; i<3; i++ )
	{
		fprintf( fp, "<TR>\n" );
		for( j=0; j<3; j++ )
		{
			fprintf( fp, "<TD>\n" );
			writeSubTable( fp, i*3, j*3, ( (i+j)%2 ? "white" : "grey" ) );
			fprintf( fp, "</TD>\n" );
		}
		fprintf( fp, "</TR>\n" );
	}
	fprintf( fp, "</TBODY>\n" );
	fprintf( fp, "</TABLE>\n" );

	fprintf( fp, "   </BODY>\n" );
	fprintf( fp, "</HTML>\n" );
	return( 1 );
}

/*
 * Rountine to validate puzzle
 *
 */

int isValid( int v[] )
{
//printf("isValid:\n");
	int i, s, a[GRID_SIZE];

	//initialize a[] to all ones
	for( i=0; i<GRID_SIZE; i++ )
		a[i] = 1;

	//set a[i] = 0 where i is the values of the solution array.
	//	If there are duplicates in v[], that value in a[] is skipped (left as '1')
	for( i=0; i<GRID_SIZE; i++ )
		a[v[i]-1] = 0;
	
	//s = sum of a[]
	for( i=0, s=0; i<GRID_SIZE; i++ )
		s += a[i];

	return( !s ); //return the sum as a boolean.
}

static long int checkCount = 0;

int isSolved()
{
//printf("isSolved:\n");
	int i, j, k, l, v[GRID_SIZE];

	checkCount++;
	//if ( !(checkCount % 1000000) )
	//	printf( "%ld, ", checkCount );

	for( i=0; i<GRID_SIZE; i++ ) // check rows
	{
		for( j=0; j<GRID_SIZE; j++ )
			v[j] = grid[i][j].val;
		if ( !isValid( v ) )
			return( 0 );
	}

	for( j=0; j<GRID_SIZE; j++ ) // check columns
	{
		for( i=0; i<GRID_SIZE; i++ )
			v[i] = grid[i][j].val;
		if ( !isValid( v ) )
			return( 0 );
	}

	for( i=0; i<BOX_SIZE; i++ ) // check squares
		for( j=0; j<BOX_SIZE; j++ )
		{
			for( k=0; k<BOX_SIZE; k++ )
				for( l=0; l<BOX_SIZE; l++ )
					v[k*BOX_SIZE+l] = grid[i*BOX_SIZE+k][j*BOX_SIZE+l].val;
			if ( !isValid( v ) )
				return( 0 );
		}

	return 1;
}

/*
 * Routines to solve puzzle
 *
 */

/*
* Use DFS to find the answer (very poor solution).
*   Only checks blank values and assumes that the initial puzzle is setup correctly.
*	For each blank, fill it (1-9) and make the recursive call to test the solution.
*	Stop recursion is the filled in value is correct.
*/
int findSolution_DFS()
{
//printf("findSolution:\n");
	register int i, j, k, flag;
	register int l, row, blanks, valid;

	flag = 0;
	for( i=0; i<GRID_SIZE; i++ )
		for( j=0; j<GRID_SIZE; j++ )
		{
			if ( !grid[i][j].val )
			{
				flag = 1;
				for( k=1; k<=GRID_SIZE; k++ )
				{
					grid[i][j].val = k;
					//only use valid numbers
					//unless there are other blanks on the row..
					for( l=row=valid=blanks=0; l<GRID_SIZE; l++ ){
						valid += (l+1);
						if (grid[i][l].val == 0)
							blanks = 1;
						else
							row += grid[i][l].val;
					}
					if ( row == valid || blanks == 1 ) //plug and search further
					{
						//printf("[%u][%u] -> %u\n", i,j,k);
						if ( findSolution_DFS() )
							return 1;
					}
				}
				grid[i][j].val = 0;
			}
		}

	return( !flag ? isSolved() : 0 );
}

/*
* findSolution_Astar()
* pre: the grid must contain a valid puzzle
*
* 1. Sweep once to find definite solutions (open slots with only one possible solution).
*	-assign the solution value and close the slot
* 2. Setup grid with initial scores and potentials 
*/
static int setup = 0;
int findSolution_Astar()
{
	int i,j,w, remove;	
	
	if ( !setup )
	{	//perform a sweep to assign all initial values and correct potential_value arrays
		for( i=0; i<GRID_SIZE; i++ )
		{
			for( j=0; j<GRID_SIZE; j++ )
			{
				//initialize possible value list for this node
				for( w=0; w<GRID_SIZE; w++ )
					grid[i][j].possible_values[w] = w+1;
				//check row
				for( w=0; w<GRID_SIZE; w++ )
				{
					remove = grid[i][w].val;
					if ( remove != 0)
						grid[i][j].possible_values[remove-1] = 0; //remove from the list.
				}
				//check col
				for( w=0; w<GRID_SIZE; w++ ) 
				{
					remove = grid[w][j].val;
					if ( remove != 0)
						grid[i][j].possible_values[remove-1] = 0; //remove from the list.
				}
				//TODO: setup a start point..
			}
		}
	/* //test for possible value arrays
	printf("possibles for 1,4:\n");
	for( i=0; i<GRID_SIZE; i++ )
		printf("%u ", grid[0][3].possible_values[i]);*/
	setup = 1; //the grid has been setup
	}

	//
	
return 1; //A* will find the solution or die trying..
}



int solvePuzzle()
{
	printf("Solving Puzzle..\n");
	return( findSolution_DFS() );
	//return( findSolution_Astar() );
}

/*
 * Routines to create puzzle
 *
 */

void createNewPuzzle( int diff )
{
	printf("created puzzle:\n");
	int i,j;
	int choices[9] = {1,2,3,4,5,6,7,8,9};
	
	//fill in the puzzle..
	for( i=0; i<GRID_SIZE; i++ ){
		for( j=0; j<GRID_SIZE; j++ )
		{
			grid[j][i].val = choices[j];
			printf("%f", grid[j][i].val);
		}
		printf("\n");
	}

	//remove a few pieces
	grid[1][1].val = 0;
	grid[2][2].val = 0;
	grid[5][5].val = 0;
}


/*
 * main routine
 *
 */

int main( int argc, char *argv[] )
{
	
	if ( !parseArgs( argc, argv ) )
		exit( 1 );

	if (  !bCreate ){
		FILE *fp;
		fp = fopen("test.grid", "r");
		if ( !readGrid( fp ) )//used to be stdin
		{
			fprintf( stderr, "error: bad problem input\n" );
			exit( 1 );
		}
	}
	else{	//printf("test");
		createNewPuzzle( iDiff );
	}

	if ( bSolve )
	{
		//Time the solver
		time_t start, end;

 		time(&start);
		if ( !solvePuzzle() )
		{
			fprintf( stderr, "error: puzzle is unsolveable\n" );
			exit( 1 );
		}
		printf( "Check Count: %ld\n", checkCount );
		time(&end);
		double total = difftime(end,start);
		printf("Time To Solve: %.4f secs",total);

	}

	if ( bHTML )
		writeHTMLPuzzle( stdout );
	else
		writeGrid( stdout );   //TODO: UNCOMMENT THIS LINE!!

	return( 0 );
}

@
