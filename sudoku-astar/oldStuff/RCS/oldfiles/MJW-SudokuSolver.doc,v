head	1.1;
access;
symbols;
locks; strict;
comment	@# @;


1.1
date	2007.02.27.21.15.30;	author mwade;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@{\rtf1\ansi\ansicpg1252\deff0
{\fonttbl
{\f0\fnil\fcharset0\fprq0\fttruetype Times New Roman;}
{\f1\fnil\fcharset0\fprq0\fttruetype Bitstream Vera Sans;}
{\f2\fnil\fcharset0\fprq0\fttruetype Dingbats;}
{\f3\fnil\fcharset0\fprq0\fttruetype Symbol;}
{\f4\fnil\fcharset0\fprq0\fttruetype Courier New;}}
{\colortbl
\red0\green0\blue0;
\red255\green255\blue255;}
{\stylesheet
{\s1\fi-429\li720\sbasedon28\snext28 Contents 1;}
{\s2\fi-429\li1440\sbasedon28\snext28 Contents 2;}
{\s3\fi-429\li2160\sbasedon28\snext28 Contents 3;}
{\s8\fi-429\li720\sbasedon28 Lower Roman List;}
{\s5\tx431\sbasedon24\snext28 Numbered Heading 1;}
{\s6\tx431\sbasedon25\snext28 Numbered Heading 2;}
{\s7\fi-429\li720 Square List;}
{\*\cs11\sbasedon28 Endnote Text;}
{\s4\fi-429\li2880\sbasedon28\snext28 Contents 4;}
{\s9\fi-429\li720 Diamond List;}
{\s10\fi-429\li720 Numbered List;}
{\*\cs12\fs20\super Endnote Reference;}
{\s13\fi-429\li720 Triangle List;}
{\s14\tx431\sbasedon26\snext28 Numbered Heading 3;}
{\s15\fi-429\li720 Dashed List;}
{\s16\fi-429\li720\sbasedon10 Upper Roman List;}
{\s17\sb440\sa60\f1\fs24\b\sbasedon28\snext28 Heading 4;}
{\s18\fi-429\li720 Heart List;}
{\s34\fi-429\li720 Box List;}
{\s20\fi-429\li720\sbasedon10 Upper Case List;}
{\s21\fi-429\li720 Bullet List;}
{\s22\fi-429\li720 Hand List;}
{\*\cs23\fs20\sbasedon28 Footnote Text;}
{\s24\sb440\sa60\f1\fs34\b\sbasedon28\snext28 Heading 1;}
{\s25\sb440\sa60\f1\fs28\b\sbasedon28\snext28 Heading 2;}
{\s19\qc\sb240\sa118\f1\fs32\b\sbasedon28\snext28 Contents Header;}
{\s27\fi-429\li720 Tick List;}
{\s26\sb440\sa60\f1\fs24\b\sbasedon28\snext28 Heading 3;}
{\s29\fi-429\li720\sbasedon10 Lower Case List;}
{\s30\li1440\ri1440\sa118\sbasedon28 Block Text;}
{\s36\f4\sbasedon28 Plain Text;}
{\s32\tx1584\sbasedon5\snext28 Section Heading;}
{\s33\fi-429\li720 Implies List;}
{\s28\f0\fs24\lang1033 Normal;}
{\s35\fi-429\li720 Star List;}
{\*\cs31\fs20\super Footnote Reference;}
{\s37\tx1584\sbasedon5\snext28 Chapter Heading;}}
\kerning0\cf0\ftnbj\fet2\ftnstart1\ftnnar\aftnnar\ftnstart1\aftnstart1\aenddoc\facingp\titlepg\revprop3{\info}\deftab720\viewkind1\paperw12240\paperh15840\margl1440\margr1440\widowctl
\sectd\sbknone\colsx360\margtsxn1260\margbsxn1170\pgncont\ltrsect
\pard\plain\ltrpar\ql\s28\itap0{\s28\f0\fs20\lang1033{\*\listtag0}\abinodiroverride\ltrch Michael Wade}{\s28\f0\fs20\lang1033{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s28\itap0{\s28\f0\fs20\lang1033{\*\listtag0}\abinodiroverride\ltrch Dr. Novobilski}{\s28\f0\fs20\lang1033{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s28\itap0{\s28\f0\fs20\lang1033{\*\listtag0}\abinodiroverride\ltrch CPSC 580 - Machine Learning}{\s28\f0\fs20\lang1033{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s28\itap0{\s28\f0\fs20\lang1033{\*\listtag0}\par}
\pard\plain\ltrpar\qc\s28\itap0{\s28\f0\fs20\lang1033{\*\listtag0}\abinodiroverride\ltrch A* Sudoku Solver}{\s28\f0\fs20\lang1033{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s28\itap0{\s28\f0\fs24\lang1033{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s28\itap0{\s28\f0\fs20\lang1033{\*\listtag0}\abinodiroverride\ltrch The A* algorithm, typically a path planning algorithm, can be used to solve grid problems such as Sudoku puzzles. The algorithm works by evaluating each possible move for the current grid state (or location) and choosing the optimal choice. The evaluation of each move is one of the traits that separates A* from other search algorithms such as DFS and Greedy Search.  Evaluation of a potential movement is based on the numerical approximation returned from the addition of two cost functions, g(n) and h(n).  The function g(n) approximates the cost of moving to grid slot n and the h(n) function (the heuristic) is an estimation of the cost to reach the solution from the grid slot.  The optimal slot is chosen based on the scores of each slot and then used as part of the solution.}{\s28\f0\fs20\lang1033{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s28\itap0{\s28\f0\fs20\lang1033{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s28\itap0{\s28\f0\fs20\lang1033{\*\listtag0}\abinodiroverride\ltrch The heuristic defined in this document contributes to solving Sudoku puzzles by extracting information about the current puzzle, using the rules of the game, and by exploiting the inner logistics of the A* algorithm.  The commonality between heuristic functions for any puzzle is their purpose: to return an accurate estimate of how optimal a certain grid slot would be as a solution choice.  Knowing this, one can use the rules of Sudoku and the context of a given puzzle state to calculate a potential cost.  }{\s28\f0\fs20\lang1033{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s28\itap0{\s28\f0\fs20\lang1033{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s28\itap0{\s28\f0\fs20\lang1033{\*\listtag0}\abinodiroverride\ltrch The heuristic that was explored for this implementation returns the number of potential values for a blank slot based on the current puzzle state.  Accomplished by checking each closed slot}{\s28\f0\fs20\super\lang1033{\*\listtag0}\chftn}{\footnote
\pard\plain\ltrpar\ql\s23\itap0{\cs23\f0\fs20\super\lang1033{\*\listtag0}\chftn}{\cs23\f0\fs20\lang1033{\*\listtag0} The A* algorithm maintains two lists, open and closed.  In Sudoku, the closed list contains all grid slots with a predefined value or a value that is assumed to be accurate.  The open list contains all slots yet to be assigned a value.}}{\s28\f0\fs20\lang1033{\*\listtag0} on the same row, column and 3x3 region, the heuristic returns a value of one to nine.  Returning values in the range of one to nine keeps the heuristic function from  overestimating the cost.  In the event that the calculation yields a zero for the slot, a nine would be returned and the function sets a flag to indicate an invalid choice was }{\s28\f0\fs20\lang1033{\*\listtag0}previously made}{\s28\f0\fs20\lang1033{\*\listtag0}.  We know a previous choice was invalid since every open slot should have a possible choice unless a mistake exists within the grid.  Since the A* algorithm was implemented using recursion, the flag would force the current iteration to return to the previous and continue to return until the error flag is removed.  The next possible path is then chosen from the slot's potential values, which were stored as an integer array in the slot's structure.}{\s28\f0\fs20\lang1033{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s28\itap0{\s28\f0\fs20\lang1033{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s28\itap0{\s28\f0\fs20\lang1033{\*\listtag0}\abinodiroverride\ltrch The other cost function, g(n), is used in addition (literally) to the heuristic function as an indicator of the slot's potential for yielding a solution.  The less the value returned by g(n), the greater the chance that A* will choose the slot as optimal for the current iteration.  The simplest way to estimate this is to subtract the number of open slots on the current slot's row, column, and 3x3 region from the total number of possible slots (8+8+4).  The hypothesis is that the less connected the slot is to the rest of the grid the greater chance that A* will be able to correctly guess the slot's value.  While the heuristic function produces an overall score, the g(n) function acts as an invisible hand that guides A* to different areas of the puzzle based on potential impact.}{\s28\f0\fs20\lang1033{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s28\itap0{\s28\f0\fs20\lang1033{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s28\itap0{\s28\f0\fs20\lang1033{\*\listtag0}\abinodiroverride\ltrch This implementation exploits the A* guessing mechanism by storing the potential values for each slot in an integer array within the slot's structure.  Initialized to one through nine, the array values are set to zero as the heuristic function finds the slot's potentials.  Each slot's  array of }{\s28\f0\fs20\lang1033{\*\listtag0}potentials}{\s28\f0\fs20\lang1033{\*\listtag0} are then used as the guessing pool from which A* will draw it's decision.  After selecting a potential guess, the recursive call is made to A* and the loop continues by scoring open slots, choosing and optimal slot, and then choosing another potential.  The process is complete when the grid is solved or determined to be unsolvable.}{\s28\f0\fs20\lang1033{\*\listtag0}\par}}@
